---
title: "Unit-Testing And Test-driven Development"
teaching: 30
exercises: 0
questions:
- "What is the benefit of unit-testing my code?"
- "How do I create and run unit tests?"
- "Why would I change my code after I got it to run?"
objectives:
- "Formalise documented examples as tests."
- "Use testthat functions to create and run tests."
keypoints:
- "Changing code is not always necessary, but often useful."
- "Tests provide a safety net for changing code."
- "Practice more TDD at [exercism.io](http://exercism.io/languages/)"
source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("16-supp-testthat-R-")
```

## Unit testing with the `testthat` package

Computer code evolves. Functions may need to be updated to new usage goals,
sped up when more data needs to be crunched, or cleaned up to make their code
more readable for collaborators, reviewers, etc. You probably know the saying
"Never change a running system!" We surely invested a lot of time already to make
sure our functions work fine now. It is natural to be cautious about changing
computer code and it rightly shouldn't be done on a whim.

However, as you have probably learned in the Git lesson, branching is one way to
try out code changes in a way that allows you to recover from mistake, and only
merge successful changes.

Unit tests are another way to "span a safety net", and in R, the [`testthat` package][testthat]
is commonly used. Because adding tests requires an expansion of the folder and file
structure of an R package, we are going to use a helper package to do this for
us: [`usethis`][usethis].

If you installed and loaded both packages alongside `roxygen2` earlier, you
should be able to immediately:

```{r use_test, eval=FALSE}
use_test("center")
```

A new file should be created called `test-center.R` and pre-filled with a little example. While
following the explanation of each part, please delete the contents of that example
test in order to prepare inserting our own. The string within `test_that("…", …)`
is an explanation of what this test actually tests. In case of our `center()`
function we expect that "centering works".

Next comes a specific `expect_`ation, usually calling a given function with
a defined set of arguments (inputs) to check whether that result is `_equal`
to a known return value (outputs).
In the function comments, we have already formalised a few of these as examples.
Copy-and-paste them into the test file, remove the `# should return [1]`
indicators of the expected results, and wrap the result values into a `c()` to
enable R to compare the expected values with the output of the two `center()` tests.

```{r center-test, eval=FALSE}
test_that("centering works", {
  expect_equal(center(c(1, 2, 3)), c(-1, 0, 1))
  expect_equal(center(c(1, 2, 3), 1), c(0, 1, 2))
})
```

Don't worry that there is no output when you execute either one or both of the
`expect_equal()` statements, or  the whole `test_that()` block. In good UNIX
tradition, `testthat` does not bother you with confirming that things are working
as expected. But there will be plenty of output when some expectations are not
met, i.e. one or more unit tests fail.

> ## Testing our rescaling functions
>
> Apply the above example of converting the examples into unit tests for the
> `rescale` function as well.
>
> > ## Solution
> > ~~~
> > test_that("rescaling works", {
> >   expect_equal(rescale(c(1, 2, 3)), c(0.0, 0.5, 1.0))
> >   expect_equal(rescale(c(1, 2, 3, 4, 5)), c(0.0, 0.25, 0.5, 0.75, 1.0))
> > })
> > ~~~
> > {: .r}
> {: .solution}
{: .challenge}

To conclude this section about creating unit tests, let's again commit our results,
for example as "Span safety net for TDD".

Finally, have a look at the websites listed on `help(usethis)` to learn about
how else it can assist you when building packages.


## Test-driven development (TDD)

Remember that we updated `rescale()` with lower and upper bounds and default
values at the end of [episode 2][02]? We had to manually test that change with a
new example back then. We were repeating ourselves a bit more often than necessary
back then, weren't we? Of course, there are ways to automate the testing of code
changes, and to give you quick feedback whether your changes worked, or broke
anything.

To give ourselves this quick feedback, use `testthat`'s `auto_test_package()`
in the console, or in RStudio's `Build` pane the `More > Test Package` menu option, 
and notice the hopefully all green and `OK` `Results`.

With this safety net enabled, we will first update `test-rescale.R`, and then
update the code in `rescale.R` This strategy of (re)writing (new)
tests before (re)writing the code-to-be-tested is called
"[test-driven design/development][TDD]". It is intended to reduce confirmation
bias when coding. If one already worked hard to get the code to run, one may be
_biased to_ let the tests _confirm_ what the code currently _does_, instead of
challenging it with tests about what it _should_ do. The latter is similar to the
scientific method of trying to disprove hypotheses, so that the truth remains.

[02]: {{ page.root }}/03-func-R/
[TDD]: https://en.wikipedia.org/wiki/Test-driven_development

> ## Update `test-rescale.R` with the second example from the roxygen comments at the end of
[episode 2][02].
>
> You can either wrap this example in its own `test_that()` with a fitting
> description, or replace one of the existing tests. Either way, the test 
> explanation(s) should afterwards be checked whether they still reflect the 
> test code.
> 
> > ## Solution
> > ~~~
> > test_that("rescaling works with non-default arguments", {
> >   expect_equal(rescale(c(1, 2, 3), 1, 2), c(1.0, 1.5, 2.0))
> > })
> > ~~~
> > {: .r}
> {: .solution}
{: .challenge}

Save the file and if `auto_test_package()` is still running, you should see one
`Failed` `Result`. If you run the `expect_that("…", …)` or `expect_equal(…)`
block interactively, an `Error` should appear. This exactly what we want to see
before working on the code. Why?

> ## Update `rescale.R` with a lower and upper bound argument and default values
>
> Don't copy-paste the code from earlier! Try instead to rely on the safety net
> and update the function code interactively, saving every now and then to
> trigger `auto_test_package()`.
> 
> > ## Solution
> > ~~~
> > rescale <- function(v, lower = 0, upper = 1) {
> >   L <- min(v)
> >   H <- max(v)
> >   result <- (v - L) / (H - L) * (upper - lower) + lower
> >   return(result)
> > }
> > ~~~
> > {: .r}
> > 
> > Don't forget to update the roxygen comments with the new `@param`s. You may
> > copy-paste these from [episode 2][02] ;-) Afterwards, also remember to `roxygenise()`
> > again.
> {: .solution}
{: .challenge}

While `auto_test_package()` is still running, play around with the code a bit more:

- change the placement of `(` parentheses `)`
- remove the `return()` statement to find out how R can implicitly return
  the correct result
- shorten the code to a 2 lines or even only 1 line

Some of those changes will result in errors, some will make the code more readable,
some will make it faster or slower.
To stop `auto_test_package()` in the console, press `Esc` or the red `STOP` button.
With automatic testing we can more quickly reach a sensible balance between investing
our time and energy into testing code improvement, while recovering from mistakes.

Finally, have a look at the websites listed under "See Also" in `help(testthat)`.

